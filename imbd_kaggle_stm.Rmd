---
title: "imdb_kaggle"
output: html_document
---

```{r setup, include=FALSE}
library(dplyr)
library(quanteda)
library(ggplot2)
library(ggrepel)
library(quanteda.textmodels)
theme_set(theme_minimal())
library(stm) # NOTE: You might need to install this
require(quanteda)
require(quanteda.corpora)
library(igraph)# NOTE: You might need to install this
library(openxlsx)
library(data.table)

```

## Kaggle Data

```{r data preparation}
dat<-read.csv("imdb_1972-2019.csv")

# Exploring the dataset
names(dat)

# Selecting the variables we are going to use and remove duplicates
# remove year and genre - we won't use them in our model
dat1 <- dat %>% 
  select(Title, Rating, Metascore, Description, Runtime..Minutes., Revenue..Millions.) %>% 
  distinct(Title, .keep_all = TRUE)
names(dat1)

# Look at duplicates 
dat %>% filter(duplicated(.[["Title"]]))
dat1 %>% filter(duplicated(.[["Title"]])) # to test that filter worked

# convert factors to character columns # remove 
dat2 <- dat1 %>%
  mutate_if(is.factor, as.character)

sapply(dat2, class) # to see current classes


###################################
# recreate corpus initialization for scraped data (perhaps move to different script later)

total<-read.xlsx("scraped_data.xlsx")
sapply(total, class) # to see current classes

# Adjust test dataset to training dataset
dat_test <- total %>% 
  select(Title, Year, Rating, Metascore, Description, Genres, Runtime..Minutes., Revenue..Millions.) %>% 
  distinct(Title, .keep_all = TRUE) %>% 
  rename(Genre = Genres)
names(dat_test)

# Convert numeric to integer 
colsnum <- c("Year", "Runtime..Minutes.")
dat_test[colsnum] <- sapply(dat_test[colsnum],as.integer)

# Check conformity 
ifelse(sapply(dat2, class) == sapply(dat_test, class), 1, 0) # if TRUE, return 1; if FALSE, return 0

dat2020 <- na.omit(dat_test) #remove films with missing information in either columns
```

## Structural Topic Model


```{r Initialize Corpus and dfm objects}
# initialize corpus and dfm objects

# Turn kaggle data into corpus
corp_kaggle <- corpus(dat2, 
       text_field = "Description",
       docid_field = "Title")

docvars(corp_kaggle, "Title") <- dat1$Title ## Add back Title

# Create a document-feature matrix to enable text analysis
#With no word limits we get 15.003 columns (so possible variables)
corp_dfm <- dfm(corp_kaggle, 
                remove_punct = TRUE, 
                remove_numbers = TRUE,
                remove_symbol = TRUE, 
                remove_separators = TRUE,
                split_hyphens = TRUE,
                remove = stopwords("en")) %>%
  dfm_trim(min_termfreq = 0.8, termfreq_type = "quantile") 
  # only keeps top 5% of words - play around with (no doc limit)

######### Scraped Data ################
  
# make corpus from scraped 2020 imdb data
corp_2020 <- corpus(dat2020, 
       text_field = "Description",
       docid_field = "Title")

docvars(corp_2020, "Title") <- dat2020$Title ## Add back Title

# make scrapped corpus into dfm 
corp_2020_dfm <- dfm(corp_2020,
                remove_punct = TRUE,
                remove_symbols = TRUE,
                remove_separators = TRUE,
                split_hyphens = TRUE,
                remove_numbers = TRUE,   
                remove = stopwords("en")) 

```

```{r Structural Topic Model Pt. 1 - build and save, eval = FALSE}
# build topic model from kaggle data
# called "mod_demo" here so that this version does not save
corp_dfm_stm <- asSTMCorpus(corp_dfm)
mod_demo <- stm(documents = corp_dfm_stm$documents, 
           vocab = corp_dfm_stm$vocab,
           K = 10, 
           data = corp_dfm_stm$data,
           seed = 12345)

#saveRDS(mod, file = "topic_mod.rds")
```

```{r Structural Topic Model Pt. 2 - import and continue}
mod <- readRDS("topic_mod.rds")

# Descriptive 
summary(mod) # shows highest probability, Lift and FREX words and score
# FREX weights words by their overall frequency and how exclusive they are to the topic.
# Lift weights words by dividing by their frequency in other topics, therefore giving higher weight to words that appear less frequently in other topics.
# Similar to lift, score divides the log frequency of the word in the topic by the log frequency of the word in other topics.

plot(mod, type = "summary", text.cex = 1) # shows highest probability words in each topic
plot(mod,
     type = "perspectives",
     topics = c(4, 5),
     main = "Putting two different topics in perspective")
# The size of the words is again relative to their frequency (within the combination of the two topics). The x-axis shows the dregree that specific words align with Topic 4 or Topic 5. 
plot(topicCorr(mod))

topicQuality(mod, documents = corp_dfm_stm$documents)
# Semantic coherence measures whether the words in a topic tend to co-occur together.
# Exclusivity measures the extent to which the top words for this topic are do not appear as top words in other topics -- i.e., the extent to which its top words are 'exclusive.'
dim(mod$beta$logbeta[[1]])

# name the topics
labels <- apply(sageLabels(mod)$marginal$frex, 1, 
                function(x){ paste(x[1:4], collapse = "-") })
                # takes FREX words and concatenates them 

thetas_kaggle <- data.frame(mod$theta)
colnames(thetas_kaggle) <- labels
rownames(thetas_kaggle) <- paste(docvars(corp_dfm)$Title)



######## Scraped Data ###########
# make 2020 dfm into STM corpus
new_docs <- asSTMCorpus(corp_2020_dfm) ## This is where films are dropped if na.omit not run (above)

# apply old topic model
new_stm <- alignCorpus(new_docs,
                       old.vocab = corp_dfm_stm$vocab)

nds <- fitNewDocuments(mod, documents = new_stm$documents,
                newData = new_stm$data)

thetas_2020 <- data.frame(nds$theta)
colnames(thetas_2020) <- labels
rownames(thetas_2020) <- paste(docvars(corp_2020_dfm)$Title)

# next step: link this spreadsheet (thetas by topic) to 2020 film data to create model


#probably not useful but cute!
library(ca)
plot(ca(thetas_kaggle))

```

```{r combine thetas into full datasets}
# add topic scores into kaggle data
thetas_kaggle <- setDT(thetas_kaggle, keep.rownames = TRUE)
names(thetas_kaggle)[1] <- "Title" 
dat_kaggle <- left_join(dat2, thetas_kaggle, by = "Title")
dat_kaggle <- select(dat_kaggle, -c(Title, Description, Year, Genre, Metascore)) # won't use for model

# add topic scores into 2020 data
thetas_2020 <- setDT(thetas_2020, keep.rownames = TRUE)
names(thetas_2020)[1] <- "Title" 
dat_2020 <- left_join(dat2020, thetas_2020, by = "Title")
```

```{r}
# test linear model 
lin_mod <- lm(Rating ~ ., data = dat_kaggle)
summary(lin_mod)
# this shows that only runtime and revenue have a positive correlation with the Rating as a simple linear model. Actually, so does "story-true-drama-based"

# let's look at interaction effects with revenue
lin_mod_rev <- lm(Rating ~ Revenue..Millions.*., data = dat_kaggle)
summary(lin_mod_int)
```



```{r does not work}

stm1effect <- estimateEffect(formula = 1:10 ~ Rating,
              stmobj = mod,
              metadata = corp_dfm_stm$data)
summary(stm1effect)


# apply topic model
old_stm <- alignCorpus(corp_dfm_stm,
                       old.vocab = corp_dfm_stm$vocab)

nods <- fitNewDocuments(mod, documents = old_stm$documents,
                newData = old_stm$data)

thetas <- data.frame(nods$theta)
colnames(thetas) <- labels
rownames(thetas) <- paste(docvars(corp_dfm)$Title)

# Attach thetas to df - doesn't make sense 
dat3 <- cbind(dat2, thetas)
dat3 <- select(dat3, -c(Title, Description, Genre))

# Model 
mood <- lm(Rating ~ ., data = dat3)
summary(mood)
predict(mood, dat3)

# Test on new data
prediction <- predict(mood, dat2020) # cannot work because categories don't exist
``` 
